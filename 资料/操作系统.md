# 操作系统

## 计算机系统基础

### 什么是操作系统

OS（operation system）是管理计算机硬件和软件资源、给应用程序和用户提供底层抽象的一种系统软件。

主要功能为：

* 硬件管理
* 文件管理
* 进程管理
* 内存管理
* 系统安全和保护
* 用户接口（GUI和CLI）
* 系统服务和应用程序支持

### 冯-诺伊曼架构？

主要组成部分：

* memory：存储计算机程序和数据。程序与数据共享同一个内存空间。
* CPU：分为控制单元（CU）和算数逻辑单元（ALU）
* 总线：地址总线、数据总线、控制总线（发控制信号的）（一般32位计算机，总线就是32位，因为CPU能运算的最大数据就是32位）
* 输入、输出设备

### 外中断和异常

均需从用户态转到内核态执行相关程序再转回来。（也就是会停止当前的程序执行转向另一个特定的处理程序）

外部中断：

* 输入/输出设备
* 计时器：计时器中断用于实现时间片轮转
* 电源管理：处理器进入低功耗模式时发出的中断

异常：

* 算数异常
* 地址异常
* 系统调用异常
* 保护异常：访问被保护的数据或执行非法操作时的异常

### CPU地址翻译

从虚拟地址到物理地址

分页系统：

将虚拟地址和物理地址都分页（4KB~12bit）

然后将虚拟地址分为虚拟地址号（20位）和页内地址（12位）->假设为32位系统，虚拟地址最高为32位4GB寻址空间

### TLB是什么

translation lookaside buffer：页表缓存

存储最近使用过的虚拟地址到物理地址的映射关系。（其实是页号）

* 替换策略：LRU（最近最少使用），随机替换等

### 局部性原理

计算机程序执行的过程中，对内存的访问集中在某个较小的地址范围内。局部性原理是高速缓存（cache）和页表缓存（TLB）的基础。

* 时间局部性：一段时间内同一个内存地址被多次访问
* 空间局部性：一段时间内，程序访问的地址倾向于一个有限的范围内

### 用户态和内核态

程序运行的正常状态 / 执行内核代码或者系统调用时的特权状态

产生：

* 外部中断
* 系统调用
* 异常

### CPU缓存和作用

L1,L2,L3级缓存

访问内存空间时先依次访问三个缓存，没找到再访问内存

（当然是已经完成虚拟地址到真实内存地址转化过程的）

### 程序执行的基本过程

* 编写程序
* 预处理、编译、汇编、链接等
* 加载：os将程序从disk加载到memory中
* 执行：CPU读取指令来执行

## 并发

### 并发和并行的区别

* 并发指的是在一段时间内，多个程序占用同一个CPU核心同时运行
* 并行指的是在同一时间，多个程序占用多个CPU核心同时运行

### 讲一讲死锁，死锁应该如何处理

彼此持有对方资源，同时等待对方释放资源才可以进行下一阶段。

有A,B两个资源，x，y两个线程，x线程给A资源加锁的中间想给B资源加锁访问，y线程给B资源加锁的中间想给A资源加锁访问，那么就会导致两个线程都占有对方想要的资源，同时等待对方释放资源。

发生死锁条件：

* 互斥：一个资源在同一时间只能由一个线程/进程占用
* 占有并等待：一个资源占有某个资源同时，还在尝试获取其他线程目前占用的资源
* 不可抢占：某个线程目前占有的资源不能被其他线程抢占，只能由该线程释放
* 循环等待：存在一个线程/进程等待序列，其中每个线程/进程都在等待上一个进程释放资源。

处理死锁：

1. 预防死锁：破坏死锁条件
2. 避免死锁：银行家算法
3. 检测和恢复死锁：
   允许进入死锁条件，然后定期检查死锁，发现死锁后进行解决。

银行家算法：

[银行家算法](https://blog.csdn.net/qq_33414271/article/details/80245715)

### 互斥锁和自旋锁，底层实现

避免数据竟态问题（多个线程、协程并发或者并行同一个数据资源，其中至少有一个线程是写入）

* 互斥锁（也就是读+写锁）：一段时间内只有一个线程/协程访问同一块资源。如果一个线程占用锁，其他线程就会阻塞。（阻塞会让出CPU资源）
* 自旋锁：和互斥锁作用基本相同，不同的是一个线程占用自旋锁时，其他线程不会释放CPU资源而是原地等待。

### linux同步机制

* 互斥锁（mutex）
* 读写锁（read-write mutex）
* 信号量（计数器）

### 信号量是怎么实现的

P操作（-1请求资源）和V操作（+1释放资源）

go语言通过使用缓冲通道来模拟信号量操作，从而实现Goroutine的并发和并行

## 进程与线程管理

### 进程、线程、协程区别和联系

进程：os分配资源和调度的最小单位。（4GB）资源相互隔离，需要使用进程通信方法。

线程：os调度的最小单位。（4MB）同一进程中线程共享资源，上下文切换成本小。

协程：也可以称作用户态线程，由各语言自己管理调度。（4KB）

### 用户线程和内核线程

将一个线程的功能相当于拆解开，需要在用户态执行的就是用户线程，在内核态执行的（包括换页中断等等）线程调度、系统调用等等方法的就是内核线程。

联想go语言的GPM调度即可

进程间通信方式

* 管道（linux上就是文件，匿名和命名管道）
* 消息队列（单链表形式组织）
* 信号（Sigkill等）
* 信号量（PV原语，访问有限资源（比如网络资源，最多允许10个连接））
* 共享内存（将两者的虚拟内存页映射到相同的物理页上）
* socket

### 进程的状态有哪些

五态模型中有：新建new，就绪ready，运行running，阻塞blocking，结束terminated

就绪到运行的切换使用调度（进程切换方式），时间片轮转也是中断一种

运行到阻塞状态是外部中断（IO操作）、等待锁、或者信号到达，进程暂停执行。

### 守护进程、僵尸进程、孤儿进程

守护进程：后台运行的特殊进程，用于提供服务或者执行定期任务

僵尸进程：父进程还在运行但是子进程挂了，但是父进程并没有回收子进程的资源，占用进程表空间的进程（没有调用wait清理信息）

孤儿进程：子进程还在运行但是父进程挂了，子进程会被init进程（PID=1）接管，定期执行wait（）函数回收
