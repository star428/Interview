## 增

1. 增加一个表
   ```mysql
   CREATE TABLE table_name (column_name column_type, ...)
   ```
2. 增加一行
   ```mysql
   INSERT INTO table_name (field1, field2, ...) VALUES (values1, values2, ...)
   ```

## 删

1. 删除一行
   ```mysql
   DELETE FROM ‘表名’[WHERE 子句]
   ```
2. 删除一个表，删除一个库
   ```mysql
   DROP TABLE table_name
   DROP DATABASE database_name
   ```

## 改

1. 改行数据
   ```mysql
   UPDATE table_name SET field1=newValue1，field2=newValue2
   WHERE [查询条件]
   ```

## 查

* 无条件查询

```sql
SELECT * FROM table_name
```

* 有条件查询

  ```sql
  SELECT * FROM table_name
  WHERE [查询条件]
  ```
* 排序

  ```sql
  SELECT * FROM table_name
  ORDER BY [A/D] [column1]
  ```
* 分组

  ```sql
  SELECT column_name, function(column_name)
  FROM table_name
  WHERE [查询条件]
  GROUP BY column_name 
  ```

  * COUNT：多少列
  * SUM：某一列的合计值，列必须是数值类型
  * AVG：某一列的平均值，列必须是数值类型
  * MAX：某一列的最大值
  * MIN：某一列的最小值
* 连接查询

  ```sql
  SELECT teacher.no, tn, cno
  FROM teacher,tc
  WHERE (teacher.tno = tc.tno) and (tn = "刘伟")
  ```
* 子查询

  ```sql
  SELECT tno,tn
  FROM teacher
  WHERE prof = {SELECT prof
                FROM teacher
                WHERE tn = "刘伟"
  }
  ```

## 事务

注意只有innoDB引擎支持事务

### 事务四大特性

ACID：原子性，一致性，隔离性，持久性

原子性（undo 日志）回滚日志

一致性（原子性+隔离性+持久性）

隔离性（MVCC和锁机制）

持久性（redo 日志）重做日志

### 并发事务会有什么问题

**脏读：**读到了其他事务未提交的数据。（未提交意味着回滚，有可能并不存在）

**不可重复读：**同一个事务中不同时间读到的数据不同，可能受到其他事务影响

**幻读：**针对插入操作，一个用户开始读的和结尾读的不相同（比如计算行数不一致，是由于其他事务插入所导致的），感觉出现了幻觉

（不可重复度侧重于修改某一行，幻读侧重于增删某一行）

可重复读：一个事务中开始和结尾读到的数据相同

### 事务的隔离级别

**读未提交：**可以读到别人未提交的数据

**读提交：**只能读到提交后的数据

**可重复读：**事务从头到尾看到的都是开始的那个数据（默认隔离级别）

**串行化：**加入读写锁，多个事务对同一个记录进行读写操作时，串行执行

### 不同事务级别下会出现什么问题

读未提交：脏读，不可重复读，幻读

读提交：不可重复读，幻读

可重复读：幻读（可以很大程度避免幻读，但是不能完全阻止幻读的发生）

串行化：都不可能发生

### MVCC（multi-version concurrency control）多版本并发控制

#### Read View中四个字段的作用

（需要注意的是read view只是在select时会产生，根据隔离级别不同read view的生成时间也不同）

创建该read view时的id | 创建read view时当前活跃未提交的id列表 | 活跃但未提交的最小id值 | 创建该read view时应该给下一个事务的id值

![1711635072487](image/Mysql/1711635072487.png)

![1711635117709](image/Mysql/1711635117709.png)

#### 聚簇索引中的两个与事务有关的隐藏列

聚簇索引就是对主键的索引，非叶子节点就是主键值，叶子索引存放的是按顺序排布的主键值和真实行的数据（而不是指向行的指针）

隐藏列有两个字段：事务id和指向undo log（回滚日志）的指针

当对某条聚簇索引（也就是行）发生改动变化的时候，将该事务的id写到这个事务id上

![1711635081265](image/Mysql/1711635081265.png)



提供数据库的并发访问和事务隔离。使得读操作不会被写操作堵塞

mysql实现了多版本二阶段锁协议，每一个版本的数据行都有一个唯一的时间戳（版本有很多）

读操作：从很多个版本中挑选一个当前查询的数据行的最大时间戳

更新操作：要更新哪个数据行，就先读拥有这个最新数据行的版本，然后创建新版本再改

### 可重复读是怎么工作的？（使用MVCC）

在事务启动时生成一个read view，然后在整个事务中都使用同一个read view即可

### 读提交是怎么工作的？（使用MVCC）

在事务中每次查询时都生成新的read view（不改变read view的id，改变里面的范围和最小值）

### 幻读如何解决的？

1. **快照读（普通select语句）**：通过MVCC解决了幻读。
2. **当前读**（使用select * ... for upgrade）：会锁定当前资源读完再释放（但是注意当前读和增删改一样都是读取最新的消息，如果快照读和当前读混着用就会发生幻读）

但是这解决不了幻读的问题，还是需要从程序员角度来解决（也就是自定义version字段的乐观锁）

## 锁

### 悲观并发控制

1. 读写锁
2. 两阶段锁协议：用来保证事务可以串行化。将整个流程分为增长和缩减阶段。增长阶段只能获取锁，缩减阶段只能释放锁。但是会导致死锁
   两个事务都要write相同的两行，顺序不用，所以两者都会持有不用的锁等待对方释放锁
   预防死锁：
   wait-die：等待先于自己的事务释放锁，或者超时回滚
   wound-wait：抢占，时间戳前的事务会抢占时间戳后的事务的锁，时间戳后的事务会回滚

锁的颗粒度：

database锁，table锁，row锁

如何在子节点加锁时，立刻判断父节点能不能加锁？

加入意向锁，意向锁不互斥，当给子节点加锁时，立刻给所有父节点加上对应的意向锁

### 乐观并发控制

乐观锁，并不是真正的锁

基于时间戳的协议

事务有时间戳，保证并行的顺序和串行下相同

每一个数据项有两个时间戳，读时间戳和写时间戳（有一个事务完成后打上相对应的事务时间戳）

**悲观和乐观并发控制都是针对程序员编写代码而言的！！！**

### 多版本并发控制

mysql实现了多版本二阶段锁协议，每一个版本的数据行都有一个唯一的时间戳（版本有很多）

读操作：从很多个版本中挑选一个当前查询的数据行的最大时间戳

更新操作：要更新哪个数据行，就先读拥有这个最新数据行的版本，然后创建新版本再改

### 锁的分类

#### 全局锁：让整个数据库处于可读状态

#### 表级锁：

#### 行级锁：

1. record lock：记录锁，仅仅只是将一条记录锁上，分S锁（读锁）和X锁（写锁）
2. Gap lock：锁住一个范围，但是不包含记录本身（存在于可重复读级别，解决幻读问题）
3. Next-key lock：record和gap的组合，锁定一个范围同时锁定记录本身
4. 插入意向锁：

## 存储引擎

### MySQL的执行引擎有哪些？

InnoDB（最常用）、MyISAM、Memory三种引擎

InnoDB：实现事务（ACID）、行级锁、外键约束

MyISAM：不支持事务，也不支持行级锁和外键约束

Memory：将数据放入内存中，数据处理极快但是效率不高

### InnoDB和MyISAM之间的区别？

| 不同               | InnoDB           | MyISAM               |
| ------------------ | ---------------- | -------------------- |
| 锁的颗粒度不同     | 行锁             | 表锁                 |
| 可恢复性           | 拥有日志         | 没有日志             |
| 记录存储顺序（行） | 主键大小顺序插入 | 按照记录插入顺序     |
| 外键和事务         | 支持             | 不支持               |
| 操作速度           | 适合查询         | 适合增加、删除、更新 |

### InnoDB是怎么实现的？

主要采用MVCC多版本并发控制和聚簇索引（也就是主键索引）的方式，提供高并发、事务支持和数据完整性

1. MVCC
2. 聚簇索引（叶子节点存储了真实的数据而不是指向数据的地址）
3. 两段式锁定（共享锁S和排他锁X）
4. 日志（新增了redo日志）
5. 并发控制

## 日志

三种日志：

### undo log 回滚日志

记录此次事务开始前的状态

实现事务的原子性，事务没提交之前，都会将当前操作的逆操作记录在回滚日志中

是实现回滚操作和MVCC的重要一步

### redo log 重做日志

记录此次事务完成后的数据状态

实现事务的持久性，记录的是当前执行的所有操作，当有事务提交时，直接将redo log中的数据写入数据库即可

### bin log 归档日志

主要用于数据备份和主从赋值

## 索引

索引是关系型数据库对其中的某一列或者某几列的值进行**预排序**的数据结构，索引也是一张表，存储着主键，索引字段和指向实体表的记录。

[B+树图片](https://cdn.xiaolincoding.com//mysql/other/b6678c667053a356f46fc5691d2f5878.png)

### 平衡二叉树

1. 首先是二叉排序树（左子树所有节点小于根节点，右子树所有节点大于等于根节点）
2. 左右子树层高相差不超过1

## B树和B+树

B树：多叉树，平衡多路查找树，所有数据即会保存非叶子节点，也会保存在叶子节点

B+树：非叶子节点不保存数据，只保存关键字的索引，所有数据都会保存到叶子节点，同时叶子节点之间是通过链表相连

### Mysql为什么使用B+树来建立索引？

优势：

1. 单点查询：B树查询有速度波动，B+树查询时均要查询到叶子节点，时间稳定。同时IO操作少（因为只需要在最后一步叶子节点才会取数据，之前都是内存中的索引）
2. 插入和删除节点：B+树中存在冗余节点，有时候直接在叶子节点中删除即可，而B树所有节点均储存数据，删除和插入需要对树进行变形
3. 范围查询：由于B+树叶子节点之间使用链表连接，所以很方便的能确定一个范围

### 索引有哪几种？

#### 单值索引

一个索引只包含单个列，一个表可以有很多单列索引

```sql
ALTER TABLE table_name ADD INDEX 索引名（列名）
```

#### 唯一索引

列值必须唯一，但是可以出现null同时可以出现多次

```sql
ALTER TABLE table_name ADD UNIQUE 索引名（列名）
```

#### 主键索引

设置主键后数据库会自动建立索引，没设置主键会有一个默认主键

#### 复合索引

一个索引包含了很多列的数据

```sql
ALTER TABLE table_name ADD INDEX 索引名（列名1，列名2）
```

#### 前缀索引

为**字符型列前几个字符**建立的索引，不是在整个字段上建立的索引

```sql
ALTER TABLE 表名 ADD 索引名(column_name(索引长度))
```

### 什么时最左匹配原则？

联合索引（复合索引）的时候使用最左匹配原则，只有查询条件中涉及联合索引中的前缀列，这个索引才可以被用到

### 使用索引的缺陷

1. 增加查询速度，但是减少增加，删除，修改速度
2. 索引也是一张表，也需要占用空间

### 什么时候需要索引

1. 主键需要索引
2. 需要标记为唯一的列需要索引
3. 经常查询的列需要索引
4. 与其他表建立外键关系的列
5. 使用经常被order by的列
6. 经常被group by的列

### 索引的优化（使用索引的注意项）

1. like的前导模糊（like ‘%XX’）不能使用索引
2. 查询范围最好使用in，可以命中索引
3. 负向条件不能使用索引（NOT, !=等）
4. 强制类型转换会导致索引失效

#### EXPLAIN语句

是分析查询执行计划的关键字，在select前加上EXPLAIN即可

主要字段：type：访问类型，查询时对表的访问方式

type：

1. ALL：最慢，遍历整个表
2. index：搜索全部索引
3. range：基于索引的范围查找
4. ref：基于索引的等值查找
5. consts：单表中最多只有一个匹配行（主键或者唯一索引）

### 索引什么时候会失效

1. 查询条件中带or，除非所有查询条件都有索引
2. like查询以%开头（字符串列）
3. 强制转换会导致索引失效
4. 索引列参与计算（count，。。。）
5. 违背最左匹配原则（聚合索引）
